package learning.flyweight;

/**
 * 使用共享对象可有效地支持大量的细粒度的对象
 *
 * 当对象有重复的时候就可以使用这个模式，类似数据库连接池，大家都可以用的对象，只是外部状态改变而不同
 *
 * 重点：
 *     内部状态(属性) 内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变
 *     外部状态(key) 对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态
 *
 * 使用场景：
 *     系统中存在大量的相似对象
 *     细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关
 *     需要缓冲池的场景
 *
 * 线程安全问题  对象池中的享元对象尽量多，躲到足够满足业务为止
 * 性能平衡   使用自己编写的类作为外部状态，必须覆写equals方法和hashCode方法，而且执行效率还比较低，这种吃力不讨好的事情最好别做，
 *          外部状态最好以Java的基本类型作为标志，如String、int等，可以大幅地提升效率。
 *
 * 其实就可以简单的想象，就是将一个对象存在MAP中，缓存起来，获取的时候看该对象有没有，没有就创建并存入到map中；有就直接返回回来，保证对象值创建了一次
 */
public abstract class Flyweight {
    //坦克型号
    protected String model;

    public Flyweight(String model) {
        this.model = model;
    }

    public abstract void drive(Troops troops);
}
